### **[문서] 코딩 테스트 스택(Stack) 문제 완전 정복 가이드**

스택은 LIFO(Last-In, First-Out) 특성을 가진 단순한 자료구조지만, 문제 해결에서는 **"아직 처리되지 않은 과거의 데이터들을 효율적으로 관리"**하는 강력한 도구로 사용됩니다. 이 가이드는 스택 문제를 해결하기 위한 체계적인 4단계 접근법을 제시합니다.

---

### **Phase 1: 문제 유형 식별 (Signal Detection)**

"이 문제가 스택을 사용하는 문제인가?"를 판단하는 단계입니다. 문제에서 아래와 같은 신호가 보이면 스택을 강력하게 고려해야 합니다.

#### **패턴 1: 모노토닉 스택 (Monotonic Stack)**

- **핵심 신호:** "각 원소에 대해, **자신과 가장 가까운** 특정 조건을 만족하는 원소를 찾아야 할 때"
- **주요 키워드:**
  - **NGE (Next Greater Element):** 오른쪽에서 나보다 큰 첫 번째 원소
  - **PGE (Previous Greater Element):** 왼쪽에서 나보다 큰 첫 번째 원소
  - **NSE (Next Smaller Element):** 오른쪽에서 나보다 작은 첫 번째 원소
  - **PSE (Previous Smaller Element):** 왼쪽에서 나보다 작은 첫 번째 원소
- **응용 문제:**
  - **히스토그램에서 가장 큰 직사각형 (BOJ 1725, 6549):** 각 막대를 최솟값으로 하는 최대 넓이 탐색
  - **부분배열 고르기 (BOJ 2104):** 각 원소를 최솟값으로 하는 최대 점수 부분배열 탐색
  - **오아시스 재결합 (BOJ 3015):** 나를 가로막는 더 큰 사람을 만나기 전까지 볼 수 있는 사람 수 계산

#### **패턴 2: 짝 맞추기 및 유효성 검사 (Pairing & Validation)**

- **핵심 신호:** "순서가 있는 데이터들 간에 짝이 맞는지, 혹은 특정 조건에 따라 소거되는지 확인할 때"
- **주요 키워드:**
  - 괄호 짝 맞추기 (`()`, `[]`, `{}`)
  - XML/HTML 태그 유효성 검사
  - 같은 아이템 제거 (게임 등)

---

### **Phase 2: 스택의 역할 및 상태 정의**

문제 유형을 파악했다면, 스택이 어떤 역할을 수행할지, 무엇을 저장할지 구체적으로 정의합니다.

#### **1. 스택의 불변성(Invariant) 정의**

- "스택에 남아있는 원소들은 어떤 조건을 항상 만족하는가?"를 정의합니다.
- **예시 (모노토닉 스택):** "스택의 원소들은 항상 오름차순(또는 내림차순)으로 정렬되어 있다." 이 규칙을 통해 스택은 항상 **"정답 후보"** 들만 담게 됩니다.

#### **2. 저장할 데이터 형태 결정**

- **`stack<int>` (값 또는 인덱스):**
  - 값 자체의 비교가 중요할 때 사용합니다.
  - 하지만 **범위, 거리, 너비 계산이 필요하다면 값 대신 인덱스를 저장하는 것이 훨씬 강력합니다.** (BOJ 2104)
- **`stack<pair<int, int>>` (값, 추가 정보):**
  - 값과 함께 **추가적인 상태 정보**(예: 개수, 시작 인덱스 등)를 함께 관리해야 할 때 사용합니다. (BOJ 3015: `{키, 같은 키 개수}`)
- **`stack<struct>`:** `pair`보다 더 복잡한 상태를 저장해야 할 때 사용합니다.

---

### **Phase 3: 알고리즘 4-Step 설계**

대부분의 스택 문제는 `for` 루프를 순회하며 아래 4단계 로직을 수행하는 구조를 가집니다.

#### **Step 1: 보조 자료구조 준비 (선택)**

- 필요하다면 스택 외의 자료구조(예: 구간 합 배열)를 미리 계산해 둡니다.

#### **Step 2: 메인 루프 진입 (데이터 순회)**

- `for (int i = 0; i < n; i++) { ... }`

#### **Step 3: 루프 내부 로직 설계 (Pop -> Process -> Push)**

- **`while` (Pop 조건):**
  - 현재 원소가 스택의 **불변성을 깨뜨리는 조건**을 `while`문에 작성합니다.
  - **(예: 오름차순 스택)** `while (!s.empty() && A[s.top()] > A[i]) { ... }`
- **`Process` (계산 시점):**
  - **계산 시점 1 (Pop 되는 순간):** `pop`이 된다는 것은, `pop`되는 원소의 탐색이 **"완결"** 되었음을 의미합니다. (예: 오른쪽 경계를 찾음). 이 순간이 정답을 계산하고 갱신하는 가장 중요한 타이밍입니다.
  - **계산 시점 2 (Pop 종료 직후):** `while` 루프가 끝난 뒤, 스택의 `top`에 남아있는 원소는 현재 원소의 **왼쪽 경계**가 됩니다.
- **`Push`:**
  - 모든 처리가 끝난 현재 원소(의 인덱스 또는 값)를 스택에 `push`하여 다음 원소들을 위한 **"후보"** 로 만듭니다.

#### **Step 4: 루프 종료 후 잔여 데이터 처리**

- `for` 루프가 끝났음에도 스택에 원소가 남아있다면, 그들은 아직 "완결"되지 않은 것입니다. (예: 오른쪽 경계를 찾지 못함)
- 이들을 배열의 끝(`n`)을 경계로 간주하여 마지막으로 처리해주는 로직이 반드시 필요합니다.

---

### **최종 점검 체크리스트**

스택 문제 풀이 전, 스스로에게 아래 질문을 던져보세요.

1.  **[유형]** 이 문제는 '가장 가까운 원소 찾기'인가, '짝 맞추기'인가?
2.  **[역할]** 스택의 불변성은 무엇인가? (오름차순, 내림차순 등)
3.  **[상태]** `int`? `index`? `pair`? 무엇을 저장해야 모든 정보를 관리할 수 있는가?
4.  **[계산]** 정답 계산은 언제 이루어져야 하는가? (`pop` 될 때? `pop` 끝난 후?)
5.  **[마무리]** 루프가 끝난 뒤 스택에 남은 원소들을 처리하는 로직이 있는가?
6.  **[예외]** 스택이 비어있는 경우(`!s.empty()`)를 항상 확인하는가? 정답 변수가 `int` 범위를 넘지 않는가(`long long`)?
